{"pytest_version": "5.2.0", "$report_type": "SessionStart"}
{"nodeid": "", "outcome": "passed", "longrepr": null, "result": null, "sections": [], "_report_type": "CollectReport"}
{"nodeid": "__init__.py", "outcome": "passed", "longrepr": null, "result": null, "sections": [], "_report_type": "CollectReport"}
{"nodeid": "Caps/__init__.py", "outcome": "passed", "longrepr": null, "result": null, "sections": [], "_report_type": "CollectReport"}
{"nodeid": "Common/__init__.py", "outcome": "passed", "longrepr": null, "result": null, "sections": [], "_report_type": "CollectReport"}
{"nodeid": "PageObjects/__init__.py", "outcome": "passed", "longrepr": null, "result": null, "sections": [], "_report_type": "CollectReport"}
{"nodeid": "PaggeLocators/__init__.py", "outcome": "passed", "longrepr": null, "result": null, "sections": [], "_report_type": "CollectReport"}
{"nodeid": "TestCases/test_0_login.py::TestLogin", "outcome": "passed", "longrepr": null, "result": null, "sections": [], "_report_type": "CollectReport"}
{"nodeid": "TestCases/test_0_login.py::TestLogin", "outcome": "passed", "longrepr": null, "result": null, "sections": [], "_report_type": "CollectReport"}
{"nodeid": "TestCases/test_0_login.py", "outcome": "passed", "longrepr": null, "result": null, "sections": [], "_report_type": "CollectReport"}
{"nodeid": "TestCases/__init__.py", "outcome": "passed", "longrepr": null, "result": null, "sections": [], "_report_type": "CollectReport"}
{"nodeid": "TestDatas/__init__.py", "outcome": "passed", "longrepr": null, "result": null, "sections": [], "_report_type": "CollectReport"}
{"nodeid": "TestCases/test_0_login.py::TestLogin::test_prepare", "location": ["TestCases\\test_0_login.py", 12, "TestLogin.test_prepare"], "keywords": {"test_0_login.py": 1, "test_prepare": 1, "TestLogin": 1, "usefixtures": 1, "test": 1, "TestCases/__init__.py": 1, "()": 1, "AppFramework": 1, "pytestmark": 1}, "outcome": "failed", "longrepr": {"reprcrash": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\util\\retry.py", "lineno": 436, "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=4723): Max retries exceeded with url: /wd/hub/session (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001E1C6F141C0>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002'))"}, "reprtraceback": {"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    @pytest.fixture()", "    def init_reset():", ">       driver = base_driver(automationName=None,noReset=True)"], "reprfuncargs": {"args": []}, "reprlocals": null, "reprfileloc": {"path": "TestCases\\conftest.py", "lineno": 66, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    driver = webdriver.Remote(\"http://127.0.0.1:{}/wd/hub\".format(server_port),descired_caps)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "TestCases\\conftest.py", "lineno": 33, "message": "in base_driver"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    super(WebDriver, self).__init__("], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\appium\\webdriver\\webdriver.py", "lineno": 147, "message": "in __init__"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    self.start_session(capabilities, browser_profile)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\selenium\\webdriver\\remote\\webdriver.py", "lineno": 157, "message": "in __init__"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    response = self.execute(RemoteCommand.NEW_SESSION, parameters)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\appium\\webdriver\\webdriver.py", "lineno": 227, "message": "in start_session"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    response = self.command_executor.execute(driver_command, params)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\selenium\\webdriver\\remote\\webdriver.py", "lineno": 319, "message": "in execute"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return self._request(command_info[0], url, body=data)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\selenium\\webdriver\\remote\\remote_connection.py", "lineno": 374, "message": "in execute"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    resp = self._conn.request(method, url, body=body, headers=headers)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\selenium\\webdriver\\remote\\remote_connection.py", "lineno": 397, "message": "in _request"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return self.request_encode_body("], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\request.py", "lineno": 79, "message": "in request"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return self.urlopen(method, url, **extra_kw)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\request.py", "lineno": 171, "message": "in request_encode_body"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    response = conn.urlopen(method, u.request_uri, **kw)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\poolmanager.py", "lineno": 330, "message": "in urlopen"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return self.urlopen("], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connectionpool.py", "lineno": 747, "message": "in urlopen"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return self.urlopen("], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connectionpool.py", "lineno": 747, "message": "in urlopen"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return self.urlopen("], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connectionpool.py", "lineno": 747, "message": "in urlopen"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    retries = retries.increment("], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connectionpool.py", "lineno": 719, "message": "in urlopen"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    def increment(", "        self,", "        method=None,", "        url=None,", "        response=None,", "        error=None,", "        _pool=None,", "        _stacktrace=None,", "    ):", "        \"\"\" Return a new Retry object with incremented retry counters.", "    ", "        :param response: A response object, or None, if the server did not", "            return a response.", "        :type response: :class:`~urllib3.response.HTTPResponse`", "        :param Exception error: An error encountered during the request, or", "            None if the response was received successfully.", "    ", "        :return: A new ``Retry`` object.", "        \"\"\"", "        if self.total is False and error:", "            # Disabled, indicate to re-raise the error.", "            raise six.reraise(type(error), error, _stacktrace)", "    ", "        total = self.total", "        if total is not None:", "            total -= 1", "    ", "        connect = self.connect", "        read = self.read", "        redirect = self.redirect", "        status_count = self.status", "        cause = \"unknown\"", "        status = None", "        redirect_location = None", "    ", "        if error and self._is_connection_error(error):", "            # Connect retry?", "            if connect is False:", "                raise six.reraise(type(error), error, _stacktrace)", "            elif connect is not None:", "                connect -= 1", "    ", "        elif error and self._is_read_error(error):", "            # Read retry?", "            if read is False or not self._is_method_retryable(method):", "                raise six.reraise(type(error), error, _stacktrace)", "            elif read is not None:", "                read -= 1", "    ", "        elif response and response.get_redirect_location():", "            # Redirect retry?", "            if redirect is not None:", "                redirect -= 1", "            cause = \"too many redirects\"", "            redirect_location = response.get_redirect_location()", "            status = response.status", "    ", "        else:", "            # Incrementing because of a server error like a 500 in", "            # status_forcelist and a the given method is in the whitelist", "            cause = ResponseError.GENERIC_ERROR", "            if response and response.status:", "                if status_count is not None:", "                    status_count -= 1", "                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)", "                status = response.status", "    ", "        history = self.history + (", "            RequestHistory(method, url, error, status, redirect_location),", "        )", "    ", "        new_retry = self.new(", "            total=total,", "            connect=connect,", "            read=read,", "            redirect=redirect,", "            status=status_count,", "            history=history,", "        )", "    ", "        if new_retry.is_exhausted():", ">           raise MaxRetryError(_pool, url, error or ResponseError(cause))", "E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=4723): Max retries exceeded with url: /wd/hub/session (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001E1C6F141C0>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002'))"], "reprfuncargs": {"args": [["self", "Retry(total=0, connect=None, read=None, redirect=None, status=None)"], ["method", "'POST'"], ["url", "'/wd/hub/session'"], ["response", "None"], ["error", "NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001E1C6F141C0>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002')"], ["_pool", "<urllib3.connectionpool.HTTPConnectionPool object at 0x000001E1C6EFA1F0>"], ["_stacktrace", "<traceback object at 0x000001E1C6F12DC0>"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\util\\retry.py", "lineno": 436, "message": "MaxRetryError"}, "style": "long"}}], "extraline": null, "style": "long"}, "sections": [], "chain": [[{"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    def _new_conn(self):", "        \"\"\" Establish a socket connection and set nodelay settings on it.", "    ", "        :return: New socket connection.", "        \"\"\"", "        extra_kw = {}", "        if self.source_address:", "            extra_kw[\"source_address\"] = self.source_address", "    ", "        if self.socket_options:", "            extra_kw[\"socket_options\"] = self.socket_options", "    ", "        try:", ">           conn = connection.create_connection(", "                (self._dns_host, self.port), self.timeout, **extra_kw", "            )"], "reprfuncargs": {"args": [["self", "<urllib3.connection.HTTPConnection object at 0x000001E1C6F141C0>"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connection.py", "lineno": 156, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    def create_connection(", "        address,", "        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,", "        source_address=None,", "        socket_options=None,", "    ):", "        \"\"\"Connect to *address* and return the socket object.", "    ", "        Convenience function.  Connect to *address* (a 2-tuple ``(host,", "        port)``) and return the socket object.  Passing the optional", "        *timeout* parameter will set the timeout on the socket instance", "        before attempting to connect.  If no *timeout* is supplied, the", "        global default timeout setting returned by :func:`getdefaulttimeout`", "        is used.  If *source_address* is set it must be a tuple of (host, port)", "        for the socket to bind as a source address before making the connection.", "        An host of '' or port 0 tells the OS to use the default.", "        \"\"\"", "    ", "        host, port = address", "        if host.startswith(\"[\"):", "            host = host.strip(\"[]\")", "        err = None", "    ", "        # Using the value from allowed_gai_family() in the context of getaddrinfo lets", "        # us select whether to work with IPv4 DNS records, IPv6 records, or both.", "        # The original create_connection function always returns all records.", "        family = allowed_gai_family()", "    ", "        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):", "            af, socktype, proto, canonname, sa = res", "            sock = None", "            try:", "                sock = socket.socket(af, socktype, proto)", "    ", "                # If provided, set socket level options before connecting.", "                _set_socket_options(sock, socket_options)", "    ", "                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:", "                    sock.settimeout(timeout)", "                if source_address:", "                    sock.bind(source_address)", "                sock.connect(sa)", "                return sock", "    ", "            except socket.error as e:", "                err = e", "                if sock is not None:", "                    sock.close()", "                    sock = None", "    ", "        if err is not None:", ">           raise err"], "reprfuncargs": {"args": [["address", "('127.0.0.1', 4723)"], ["timeout", "<object object at 0x000001E1C577A580>"], ["source_address", "None"], ["socket_options", "[(6, 1, 1)]"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\util\\connection.py", "lineno": 84, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    def create_connection(", "        address,", "        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,", "        source_address=None,", "        socket_options=None,", "    ):", "        \"\"\"Connect to *address* and return the socket object.", "    ", "        Convenience function.  Connect to *address* (a 2-tuple ``(host,", "        port)``) and return the socket object.  Passing the optional", "        *timeout* parameter will set the timeout on the socket instance", "        before attempting to connect.  If no *timeout* is supplied, the", "        global default timeout setting returned by :func:`getdefaulttimeout`", "        is used.  If *source_address* is set it must be a tuple of (host, port)", "        for the socket to bind as a source address before making the connection.", "        An host of '' or port 0 tells the OS to use the default.", "        \"\"\"", "    ", "        host, port = address", "        if host.startswith(\"[\"):", "            host = host.strip(\"[]\")", "        err = None", "    ", "        # Using the value from allowed_gai_family() in the context of getaddrinfo lets", "        # us select whether to work with IPv4 DNS records, IPv6 records, or both.", "        # The original create_connection function always returns all records.", "        family = allowed_gai_family()", "    ", "        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):", "            af, socktype, proto, canonname, sa = res", "            sock = None", "            try:", "                sock = socket.socket(af, socktype, proto)", "    ", "                # If provided, set socket level options before connecting.", "                _set_socket_options(sock, socket_options)", "    ", "                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:", "                    sock.settimeout(timeout)", "                if source_address:", "                    sock.bind(source_address)", ">               sock.connect(sa)", "E               ConnectionRefusedError: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002"], "reprfuncargs": {"args": [["address", "('127.0.0.1', 4723)"], ["timeout", "<object object at 0x000001E1C577A580>"], ["source_address", "None"], ["socket_options", "[(6, 1, 1)]"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\util\\connection.py", "lineno": 74, "message": "ConnectionRefusedError"}, "style": "long"}}], "extraline": null, "style": "long"}, {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\util\\connection.py", "lineno": 74, "message": "ConnectionRefusedError: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002"}, "During handling of the above exception, another exception occurred:"], [{"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    def urlopen(", "        self,", "        method,", "        url,", "        body=None,", "        headers=None,", "        retries=None,", "        redirect=True,", "        assert_same_host=True,", "        timeout=_Default,", "        pool_timeout=None,", "        release_conn=None,", "        chunked=False,", "        body_pos=None,", "        **response_kw", "    ):", "        \"\"\"", "        Get a connection from the pool and perform an HTTP request. This is the", "        lowest level call for making a request, so you'll need to specify all", "        the raw details.", "    ", "        .. note::", "    ", "           More commonly, it's appropriate to use a convenience method provided", "           by :class:`.RequestMethods`, such as :meth:`request`.", "    ", "        .. note::", "    ", "           `release_conn` will only behave as expected if", "           `preload_content=False` because we want to make", "           `preload_content=False` the default behaviour someday soon without", "           breaking backwards compatibility.", "    ", "        :param method:", "            HTTP request method (such as GET, POST, PUT, etc.)", "    ", "        :param body:", "            Data to send in the request body (useful for creating", "            POST requests, see HTTPConnectionPool.post_url for", "            more convenience).", "    ", "        :param headers:", "            Dictionary of custom headers to send, such as User-Agent,", "            If-None-Match, etc. If None, pool headers are used. If provided,", "            these headers completely replace any pool-specific headers.", "    ", "        :param retries:", "            Configure the number of retries to allow before raising a", "            :class:`~urllib3.exceptions.MaxRetryError` exception.", "    ", "            Pass ``None`` to retry until you receive a response. Pass a", "            :class:`~urllib3.util.retry.Retry` object for fine-grained control", "            over different types of retries.", "            Pass an integer number to retry connection errors that many times,", "            but no other types of errors. Pass zero to never retry.", "    ", "            If ``False``, then retries are disabled and any exception is raised", "            immediately. Also, instead of raising a MaxRetryError on redirects,", "            the redirect response will be returned.", "    ", "        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.", "    ", "        :param redirect:", "            If True, automatically handle redirects (status codes 301, 302,", "            303, 307, 308). Each redirect counts as a retry. Disabling retries", "            will disable redirect, too.", "    ", "        :param assert_same_host:", "            If ``True``, will make sure that the host of the pool requests is", "            consistent else will raise HostChangedError. When False, you can", "            use the pool on an HTTP proxy and request foreign hosts.", "    ", "        :param timeout:", "            If specified, overrides the default timeout for this one", "            request. It may be a float (in seconds) or an instance of", "            :class:`urllib3.util.Timeout`.", "    ", "        :param pool_timeout:", "            If set and the pool is set to block=True, then this method will", "            block for ``pool_timeout`` seconds and raise EmptyPoolError if no", "            connection is available within the time period.", "    ", "        :param release_conn:", "            If False, then the urlopen call will not release the connection", "            back into the pool once a response is received (but will release if", "            you read the entire contents of the response such as when", "            `preload_content=True`). This is useful if you're not preloading", "            the response's content immediately. You will need to call", "            ``r.release_conn()`` on the response ``r`` to return the connection", "            back into the pool. If None, it takes the value of", "            ``response_kw.get('preload_content', True)``.", "    ", "        :param chunked:", "            If True, urllib3 will send the body using chunked transfer", "            encoding. Otherwise, urllib3 will send the body using the standard", "            content-length form. Defaults to False.", "    ", "        :param int body_pos:", "            Position to seek to in file-like body in the event of a retry or", "            redirect. Typically this won't need to be set because urllib3 will", "            auto-populate the value when needed.", "    ", "        :param \\\\**response_kw:", "            Additional parameters are passed to", "            :meth:`urllib3.response.HTTPResponse.from_httplib`", "        \"\"\"", "        if headers is None:", "            headers = self.headers", "    ", "        if not isinstance(retries, Retry):", "            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)", "    ", "        if release_conn is None:", "            release_conn = response_kw.get(\"preload_content\", True)", "    ", "        # Check host", "        if assert_same_host and not self.is_same_host(url):", "            raise HostChangedError(self, url, retries)", "    ", "        # Ensure that the URL we're connecting to is properly encoded", "        if url.startswith(\"/\"):", "            url = six.ensure_str(_encode_target(url))", "        else:", "            url = six.ensure_str(parse_url(url).url)", "    ", "        conn = None", "    ", "        # Track whether `conn` needs to be released before", "        # returning/raising/recursing. Update this variable if necessary, and", "        # leave `release_conn` constant throughout the function. That way, if", "        # the function recurses, the original value of `release_conn` will be", "        # passed down into the recursive call, and its value will be respected.", "        #", "        # See issue #651 [1] for details.", "        #", "        # [1] <https://github.com/urllib3/urllib3/issues/651>", "        release_this_conn = release_conn", "    ", "        # Merge the proxy headers. Only do this in HTTP. We have to copy the", "        # headers dict so we can safely change it without those changes being", "        # reflected in anyone else's copy.", "        if self.scheme == \"http\":", "            headers = headers.copy()", "            headers.update(self.proxy_headers)", "    ", "        # Must keep the exception bound to a separate variable or else Python 3", "        # complains about UnboundLocalError.", "        err = None", "    ", "        # Keep track of whether we cleanly exited the except block. This", "        # ensures we do proper cleanup in finally.", "        clean_exit = False", "    ", "        # Rewind body position, if needed. Record current position", "        # for future rewinds in the event of a redirect/retry.", "        body_pos = set_file_position(body, body_pos)", "    ", "        try:", "            # Request a connection from the queue.", "            timeout_obj = self._get_timeout(timeout)", "            conn = self._get_conn(timeout=pool_timeout)", "    ", "            conn.timeout = timeout_obj.connect_timeout", "    ", "            is_new_proxy_conn = self.proxy is not None and not getattr(", "                conn, \"sock\", None", "            )", "            if is_new_proxy_conn:", "                self._prepare_proxy(conn)", "    ", "            # Make the request on the httplib connection object.", ">           httplib_response = self._make_request(", "                conn,", "                method,", "                url,", "                timeout=timeout_obj,", "                body=body,", "                headers=headers,", "                chunked=chunked,", "            )"], "reprfuncargs": {"args": [["self", "<urllib3.connectionpool.HTTPConnectionPool object at 0x000001E1C6EFA1F0>"], ["method", "'POST'"], ["url", "'/wd/hub/session'"], ["body", "'{\"capabilities\": {\"firstMatch\": [{\"platformName\": \"Android\", \"appium:platformVersion\": 9.0, \"appium:deviceName\": \"And...\"noReset\": true, \"appPackage\": \"com.xxzb.fenwoo\", \"appActivity\": \"com.xxzb.fenwoo.activity.addition.WelcomeActivity\"}}'"], ["headers", "{'Accept': 'application/json', 'Connection': 'keep-alive', 'Content-Type': 'application/json;charset=UTF-8', 'User-Agent': 'appium/python 0.50 (selenium/3.141.0 (python windows))'}"], ["retries", "Retry(total=0, connect=None, read=None, redirect=None, status=None)"], ["redirect", "False"], ["assert_same_host", "False"], ["timeout", "<object object at 0x000001E1C69881B0>"], ["pool_timeout", "None"], ["release_conn", "True"], ["chunked", "False"], ["body_pos", "None"], ["response_kw", "{'request_url': 'http://127.0.0.1:4723/wd/hub/session'}"], ["conn", "None"], ["release_this_conn", "True"], ["err", "None"], ["clean_exit", "False"], ["timeout_obj", "<urllib3.util.timeout.Timeout object at 0x000001E1C6F14190>"], ["is_new_proxy_conn", "False"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connectionpool.py", "lineno": 665, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    def _make_request(", "        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw", "    ):", "        \"\"\"", "        Perform a request on a given urllib connection object taken from our", "        pool.", "    ", "        :param conn:", "            a connection from one of our connection pools", "    ", "        :param timeout:", "            Socket timeout in seconds for the request. This can be a", "            float or integer, which will set the same timeout value for", "            the socket connect and the socket read, or an instance of", "            :class:`urllib3.util.Timeout`, which gives you more fine-grained", "            control over your timeouts.", "        \"\"\"", "        self.num_requests += 1", "    ", "        timeout_obj = self._get_timeout(timeout)", "        timeout_obj.start_connect()", "        conn.timeout = timeout_obj.connect_timeout", "    ", "        # Trigger any extra validation we need to do.", "        try:", "            self._validate_conn(conn)", "        except (SocketTimeout, BaseSSLError) as e:", "            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.", "            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)", "            raise", "    ", "        # conn.request() calls httplib.*.request, not the method in", "        # urllib3.request. It also calls makefile (recv) on the socket.", "        if chunked:", "            conn.request_chunked(method, url, **httplib_request_kw)", "        else:", ">           conn.request(method, url, **httplib_request_kw)"], "reprfuncargs": {"args": [["self", "<urllib3.connectionpool.HTTPConnectionPool object at 0x000001E1C6EFA1F0>"], ["conn", "<urllib3.connection.HTTPConnection object at 0x000001E1C6F141C0>"], ["method", "'POST'"], ["url", "'/wd/hub/session'"], ["timeout", "<urllib3.util.timeout.Timeout object at 0x000001E1C6F14190>"], ["chunked", "False"], ["httplib_request_kw", "{'body': '{\"capabilities\": {\"firstMatch\": [{\"platformName\": \"Android\", \"appium:platformVersion\": 9.0, \"appium:deviceNa...ntent-Type': 'application/json;charset=UTF-8', 'User-Agent': 'appium/python 0.50 (selenium/3.141.0 (python windows))'}}"], ["timeout_obj", "<urllib3.util.timeout.Timeout object at 0x000001E1C6F14220>"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connectionpool.py", "lineno": 387, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    def request(self, method, url, body=None, headers={}, *,", "                encode_chunked=False):", "        \"\"\"Send a complete request to the server.\"\"\"", ">       self._send_request(method, url, body, headers, encode_chunked)"], "reprfuncargs": {"args": [["self", "<urllib3.connection.HTTPConnection object at 0x000001E1C6F141C0>"], ["method", "'POST'"], ["url", "'/wd/hub/session'"], ["body", "'{\"capabilities\": {\"firstMatch\": [{\"platformName\": \"Android\", \"appium:platformVersion\": 9.0, \"appium:deviceName\": \"And...\"noReset\": true, \"appPackage\": \"com.xxzb.fenwoo\", \"appActivity\": \"com.xxzb.fenwoo.activity.addition.WelcomeActivity\"}}'"], ["headers", "{'Accept': 'application/json', 'Connection': 'keep-alive', 'Content-Type': 'application/json;charset=UTF-8', 'User-Agent': 'appium/python 0.50 (selenium/3.141.0 (python windows))'}"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\http\\client.py", "lineno": 1230, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    def _send_request(self, method, url, body, headers, encode_chunked):", "        # Honor explicitly requested Host: and Accept-Encoding: headers.", "        header_names = frozenset(k.lower() for k in headers)", "        skips = {}", "        if 'host' in header_names:", "            skips['skip_host'] = 1", "        if 'accept-encoding' in header_names:", "            skips['skip_accept_encoding'] = 1", "    ", "        self.putrequest(method, url, **skips)", "    ", "        # chunked encoding will happen if HTTP/1.1 is used and either", "        # the caller passes encode_chunked=True or the following", "        # conditions hold:", "        # 1. content-length has not been explicitly set", "        # 2. the body is a file or iterable, but not a str or bytes-like", "        # 3. Transfer-Encoding has NOT been explicitly set by the caller", "    ", "        if 'content-length' not in header_names:", "            # only chunk body if not explicitly set for backwards", "            # compatibility, assuming the client code is already handling the", "            # chunking", "            if 'transfer-encoding' not in header_names:", "                # if content-length cannot be automatically determined, fall", "                # back to chunked encoding", "                encode_chunked = False", "                content_length = self._get_content_length(body, method)", "                if content_length is None:", "                    if body is not None:", "                        if self.debuglevel > 0:", "                            print('Unable to determine size of %r' % body)", "                        encode_chunked = True", "                        self.putheader('Transfer-Encoding', 'chunked')", "                else:", "                    self.putheader('Content-Length', str(content_length))", "        else:", "            encode_chunked = False", "    ", "        for hdr, value in headers.items():", "            self.putheader(hdr, value)", "        if isinstance(body, str):", "            # RFC 2616 Section 3.7.1 says that text default has a", "            # default charset of iso-8859-1.", "            body = _encode(body, 'body')", ">       self.endheaders(body, encode_chunked=encode_chunked)"], "reprfuncargs": {"args": [["self", "<urllib3.connection.HTTPConnection object at 0x000001E1C6F141C0>"], ["method", "'POST'"], ["url", "'/wd/hub/session'"], ["body", "b'{\"capabilities\": {\"firstMatch\": [{\"platformName\": \"Android\", \"appium:platformVersion\": 9.0, \"appium:deviceName\": \"An...\"noReset\": true, \"appPackage\": \"com.xxzb.fenwoo\", \"appActivity\": \"com.xxzb.fenwoo.activity.addition.WelcomeActivity\"}}'"], ["headers", "{'Accept': 'application/json', 'Connection': 'keep-alive', 'Content-Type': 'application/json;charset=UTF-8', 'User-Agent': 'appium/python 0.50 (selenium/3.141.0 (python windows))'}"], ["encode_chunked", "False"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\http\\client.py", "lineno": 1276, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    def endheaders(self, message_body=None, *, encode_chunked=False):", "        \"\"\"Indicate that the last header line has been sent to the server.", "    ", "        This method sends the request to the server.  The optional message_body", "        argument can be used to pass a message body associated with the", "        request.", "        \"\"\"", "        if self.__state == _CS_REQ_STARTED:", "            self.__state = _CS_REQ_SENT", "        else:", "            raise CannotSendHeader()", ">       self._send_output(message_body, encode_chunked=encode_chunked)"], "reprfuncargs": {"args": [["self", "<urllib3.connection.HTTPConnection object at 0x000001E1C6F141C0>"], ["message_body", "b'{\"capabilities\": {\"firstMatch\": [{\"platformName\": \"Android\", \"appium:platformVersion\": 9.0, \"appium:deviceName\": \"An...\"noReset\": true, \"appPackage\": \"com.xxzb.fenwoo\", \"appActivity\": \"com.xxzb.fenwoo.activity.addition.WelcomeActivity\"}}'"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\http\\client.py", "lineno": 1225, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    def _send_output(self, message_body=None, encode_chunked=False):", "        \"\"\"Send the currently buffered request and clear the buffer.", "    ", "        Appends an extra \\\\r\\\\n to the buffer.", "        A message_body may be specified, to be appended to the request.", "        \"\"\"", "        self._buffer.extend((b\"\", b\"\"))", "        msg = b\"\\r\\n\".join(self._buffer)", "        del self._buffer[:]", ">       self.send(msg)"], "reprfuncargs": {"args": [["self", "<urllib3.connection.HTTPConnection object at 0x000001E1C6F141C0>"], ["message_body", "b'{\"capabilities\": {\"firstMatch\": [{\"platformName\": \"Android\", \"appium:platformVersion\": 9.0, \"appium:deviceName\": \"An...\"noReset\": true, \"appPackage\": \"com.xxzb.fenwoo\", \"appActivity\": \"com.xxzb.fenwoo.activity.addition.WelcomeActivity\"}}'"], ["encode_chunked", "False"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\http\\client.py", "lineno": 1004, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    def send(self, data):", "        \"\"\"Send `data' to the server.", "        ``data`` can be a string object, a bytes object, an array object, a", "        file-like object that supports a .read() method, or an iterable object.", "        \"\"\"", "    ", "        if self.sock is None:", "            if self.auto_open:", ">               self.connect()"], "reprfuncargs": {"args": [["self", "<urllib3.connection.HTTPConnection object at 0x000001E1C6F141C0>"], ["data", "b'POST /wd/hub/session HTTP/1.1\\r\\nHost: 127.0.0.1:4723\\r\\nAccept-Encoding: identity\\r\\nContent-Length: 565\\r\\nAccept:...;charset=UTF-8\\r\\nUser-Agent: appium/python 0.50 (selenium/3.141.0 (python windows))\\r\\nConnection: keep-alive\\r\\n\\r\\n'"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\http\\client.py", "lineno": 944, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    def connect(self):", ">       conn = self._new_conn()"], "reprfuncargs": {"args": [["self", "<urllib3.connection.HTTPConnection object at 0x000001E1C6F141C0>"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connection.py", "lineno": 184, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    def _new_conn(self):", "        \"\"\" Establish a socket connection and set nodelay settings on it.", "    ", "        :return: New socket connection.", "        \"\"\"", "        extra_kw = {}", "        if self.source_address:", "            extra_kw[\"source_address\"] = self.source_address", "    ", "        if self.socket_options:", "            extra_kw[\"socket_options\"] = self.socket_options", "    ", "        try:", "            conn = connection.create_connection(", "                (self._dns_host, self.port), self.timeout, **extra_kw", "            )", "    ", "        except SocketTimeout:", "            raise ConnectTimeoutError(", "                self,", "                \"Connection to %s timed out. (connect timeout=%s)\"", "                % (self.host, self.timeout),", "            )", "    ", "        except SocketError as e:", ">           raise NewConnectionError(", "                self, \"Failed to establish a new connection: %s\" % e", "            )", "E           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x000001E1C6F141C0>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002"], "reprfuncargs": {"args": [["self", "<urllib3.connection.HTTPConnection object at 0x000001E1C6F141C0>"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connection.py", "lineno": 168, "message": "NewConnectionError"}, "style": "long"}}], "extraline": null, "style": "long"}, {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connection.py", "lineno": 168, "message": "urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x000001E1C6F141C0>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002"}, "During handling of the above exception, another exception occurred:"], [{"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    @pytest.fixture()", "    def init_reset():", ">       driver = base_driver(automationName=None,noReset=True)"], "reprfuncargs": {"args": []}, "reprlocals": null, "reprfileloc": {"path": "TestCases\\conftest.py", "lineno": 66, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    driver = webdriver.Remote(\"http://127.0.0.1:{}/wd/hub\".format(server_port),descired_caps)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "TestCases\\conftest.py", "lineno": 33, "message": "in base_driver"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    super(WebDriver, self).__init__("], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\appium\\webdriver\\webdriver.py", "lineno": 147, "message": "in __init__"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    self.start_session(capabilities, browser_profile)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\selenium\\webdriver\\remote\\webdriver.py", "lineno": 157, "message": "in __init__"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    response = self.execute(RemoteCommand.NEW_SESSION, parameters)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\appium\\webdriver\\webdriver.py", "lineno": 227, "message": "in start_session"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    response = self.command_executor.execute(driver_command, params)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\selenium\\webdriver\\remote\\webdriver.py", "lineno": 319, "message": "in execute"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return self._request(command_info[0], url, body=data)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\selenium\\webdriver\\remote\\remote_connection.py", "lineno": 374, "message": "in execute"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    resp = self._conn.request(method, url, body=body, headers=headers)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\selenium\\webdriver\\remote\\remote_connection.py", "lineno": 397, "message": "in _request"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return self.request_encode_body("], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\request.py", "lineno": 79, "message": "in request"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return self.urlopen(method, url, **extra_kw)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\request.py", "lineno": 171, "message": "in request_encode_body"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    response = conn.urlopen(method, u.request_uri, **kw)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\poolmanager.py", "lineno": 330, "message": "in urlopen"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return self.urlopen("], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connectionpool.py", "lineno": 747, "message": "in urlopen"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return self.urlopen("], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connectionpool.py", "lineno": 747, "message": "in urlopen"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return self.urlopen("], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connectionpool.py", "lineno": 747, "message": "in urlopen"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    retries = retries.increment("], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connectionpool.py", "lineno": 719, "message": "in urlopen"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    def increment(", "        self,", "        method=None,", "        url=None,", "        response=None,", "        error=None,", "        _pool=None,", "        _stacktrace=None,", "    ):", "        \"\"\" Return a new Retry object with incremented retry counters.", "    ", "        :param response: A response object, or None, if the server did not", "            return a response.", "        :type response: :class:`~urllib3.response.HTTPResponse`", "        :param Exception error: An error encountered during the request, or", "            None if the response was received successfully.", "    ", "        :return: A new ``Retry`` object.", "        \"\"\"", "        if self.total is False and error:", "            # Disabled, indicate to re-raise the error.", "            raise six.reraise(type(error), error, _stacktrace)", "    ", "        total = self.total", "        if total is not None:", "            total -= 1", "    ", "        connect = self.connect", "        read = self.read", "        redirect = self.redirect", "        status_count = self.status", "        cause = \"unknown\"", "        status = None", "        redirect_location = None", "    ", "        if error and self._is_connection_error(error):", "            # Connect retry?", "            if connect is False:", "                raise six.reraise(type(error), error, _stacktrace)", "            elif connect is not None:", "                connect -= 1", "    ", "        elif error and self._is_read_error(error):", "            # Read retry?", "            if read is False or not self._is_method_retryable(method):", "                raise six.reraise(type(error), error, _stacktrace)", "            elif read is not None:", "                read -= 1", "    ", "        elif response and response.get_redirect_location():", "            # Redirect retry?", "            if redirect is not None:", "                redirect -= 1", "            cause = \"too many redirects\"", "            redirect_location = response.get_redirect_location()", "            status = response.status", "    ", "        else:", "            # Incrementing because of a server error like a 500 in", "            # status_forcelist and a the given method is in the whitelist", "            cause = ResponseError.GENERIC_ERROR", "            if response and response.status:", "                if status_count is not None:", "                    status_count -= 1", "                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)", "                status = response.status", "    ", "        history = self.history + (", "            RequestHistory(method, url, error, status, redirect_location),", "        )", "    ", "        new_retry = self.new(", "            total=total,", "            connect=connect,", "            read=read,", "            redirect=redirect,", "            status=status_count,", "            history=history,", "        )", "    ", "        if new_retry.is_exhausted():", ">           raise MaxRetryError(_pool, url, error or ResponseError(cause))", "E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=4723): Max retries exceeded with url: /wd/hub/session (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001E1C6F141C0>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002'))"], "reprfuncargs": {"args": [["self", "Retry(total=0, connect=None, read=None, redirect=None, status=None)"], ["method", "'POST'"], ["url", "'/wd/hub/session'"], ["response", "None"], ["error", "NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001E1C6F141C0>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002')"], ["_pool", "<urllib3.connectionpool.HTTPConnectionPool object at 0x000001E1C6EFA1F0>"], ["_stacktrace", "<traceback object at 0x000001E1C6F12DC0>"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\util\\retry.py", "lineno": 436, "message": "MaxRetryError"}, "style": "long"}}], "extraline": null, "style": "long"}, {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\util\\retry.py", "lineno": 436, "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=4723): Max retries exceeded with url: /wd/hub/session (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001E1C6F141C0>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002'))"}, null]]}, "when": "setup", "user_properties": [], "sections": [["Captured log setup", "\u001b[32mINFO    \u001b[0m root:conftest.py:60 xxxxxxx\n\u001b[32mINFO    \u001b[0m selenium.webdriver.remote.remote_connection:remote_connection.py:116 Could not connect to port 4723 on host 127.0.0.1\n\u001b[32mINFO    \u001b[0m selenium.webdriver.remote.remote_connection:remote_connection.py:135 Could not get IP address for host: 127.0.0.1\n\u001b[33mWARNING \u001b[0m urllib3.connectionpool:connectionpool.py:744 Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001E1C6EFAB80>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002')': /wd/hub/session\n\u001b[33mWARNING \u001b[0m urllib3.connectionpool:connectionpool.py:744 Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001E1C6EFAE50>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002')': /wd/hub/session\n\u001b[33mWARNING \u001b[0m urllib3.connectionpool:connectionpool.py:744 Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001E1C6EFAFD0>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002')': /wd/hub/session"]], "duration": 5.110398054122925, "_report_type": "TestReport"}
{"nodeid": "TestCases/test_0_login.py::TestLogin::test_prepare", "location": ["TestCases\\test_0_login.py", 12, "TestLogin.test_prepare"], "keywords": {"test_0_login.py": 1, "test_prepare": 1, "TestLogin": 1, "usefixtures": 1, "test": 1, "TestCases/__init__.py": 1, "()": 1, "AppFramework": 1, "pytestmark": 1}, "outcome": "passed", "longrepr": null, "when": "teardown", "user_properties": [], "sections": [["Captured log setup", "\u001b[32mINFO    \u001b[0m root:conftest.py:60 xxxxxxx\n\u001b[32mINFO    \u001b[0m selenium.webdriver.remote.remote_connection:remote_connection.py:116 Could not connect to port 4723 on host 127.0.0.1\n\u001b[32mINFO    \u001b[0m selenium.webdriver.remote.remote_connection:remote_connection.py:135 Could not get IP address for host: 127.0.0.1\n\u001b[33mWARNING \u001b[0m urllib3.connectionpool:connectionpool.py:744 Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001E1C6EFAB80>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002')': /wd/hub/session\n\u001b[33mWARNING \u001b[0m urllib3.connectionpool:connectionpool.py:744 Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001E1C6EFAE50>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002')': /wd/hub/session\n\u001b[33mWARNING \u001b[0m urllib3.connectionpool:connectionpool.py:744 Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001E1C6EFAFD0>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002')': /wd/hub/session"]], "duration": 0.0, "_report_type": "TestReport"}
{"nodeid": "TestCases/test_0_login.py::TestLogin::test_login_success", "location": ["TestCases\\test_0_login.py", 23, "TestLogin.test_login_success"], "keywords": {"test_0_login.py": 1, "test_login_success": 1, "TestLogin": 1, "usefixtures": 1, "test": 1, "TestCases/__init__.py": 1, "()": 1, "AppFramework": 1, "pytestmark": 1}, "outcome": "failed", "longrepr": {"reprcrash": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\util\\retry.py", "lineno": 436, "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=4723): Max retries exceeded with url: /wd/hub/session (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001E1C784DDF0>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002'))"}, "reprtraceback": {"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    @pytest.fixture()", "    def init_keep():", ">       driver = base_driver(automationName=None,noReset=False)"], "reprfuncargs": {"args": []}, "reprlocals": null, "reprfileloc": {"path": "TestCases\\conftest.py", "lineno": 75, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    driver = webdriver.Remote(\"http://127.0.0.1:{}/wd/hub\".format(server_port),descired_caps)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "TestCases\\conftest.py", "lineno": 33, "message": "in base_driver"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    super(WebDriver, self).__init__("], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\appium\\webdriver\\webdriver.py", "lineno": 147, "message": "in __init__"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    self.start_session(capabilities, browser_profile)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\selenium\\webdriver\\remote\\webdriver.py", "lineno": 157, "message": "in __init__"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    response = self.execute(RemoteCommand.NEW_SESSION, parameters)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\appium\\webdriver\\webdriver.py", "lineno": 227, "message": "in start_session"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    response = self.command_executor.execute(driver_command, params)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\selenium\\webdriver\\remote\\webdriver.py", "lineno": 319, "message": "in execute"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return self._request(command_info[0], url, body=data)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\selenium\\webdriver\\remote\\remote_connection.py", "lineno": 374, "message": "in execute"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    resp = self._conn.request(method, url, body=body, headers=headers)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\selenium\\webdriver\\remote\\remote_connection.py", "lineno": 397, "message": "in _request"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return self.request_encode_body("], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\request.py", "lineno": 79, "message": "in request"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return self.urlopen(method, url, **extra_kw)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\request.py", "lineno": 171, "message": "in request_encode_body"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    response = conn.urlopen(method, u.request_uri, **kw)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\poolmanager.py", "lineno": 330, "message": "in urlopen"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return self.urlopen("], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connectionpool.py", "lineno": 747, "message": "in urlopen"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return self.urlopen("], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connectionpool.py", "lineno": 747, "message": "in urlopen"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return self.urlopen("], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connectionpool.py", "lineno": 747, "message": "in urlopen"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    retries = retries.increment("], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connectionpool.py", "lineno": 719, "message": "in urlopen"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    def increment(", "        self,", "        method=None,", "        url=None,", "        response=None,", "        error=None,", "        _pool=None,", "        _stacktrace=None,", "    ):", "        \"\"\" Return a new Retry object with incremented retry counters.", "    ", "        :param response: A response object, or None, if the server did not", "            return a response.", "        :type response: :class:`~urllib3.response.HTTPResponse`", "        :param Exception error: An error encountered during the request, or", "            None if the response was received successfully.", "    ", "        :return: A new ``Retry`` object.", "        \"\"\"", "        if self.total is False and error:", "            # Disabled, indicate to re-raise the error.", "            raise six.reraise(type(error), error, _stacktrace)", "    ", "        total = self.total", "        if total is not None:", "            total -= 1", "    ", "        connect = self.connect", "        read = self.read", "        redirect = self.redirect", "        status_count = self.status", "        cause = \"unknown\"", "        status = None", "        redirect_location = None", "    ", "        if error and self._is_connection_error(error):", "            # Connect retry?", "            if connect is False:", "                raise six.reraise(type(error), error, _stacktrace)", "            elif connect is not None:", "                connect -= 1", "    ", "        elif error and self._is_read_error(error):", "            # Read retry?", "            if read is False or not self._is_method_retryable(method):", "                raise six.reraise(type(error), error, _stacktrace)", "            elif read is not None:", "                read -= 1", "    ", "        elif response and response.get_redirect_location():", "            # Redirect retry?", "            if redirect is not None:", "                redirect -= 1", "            cause = \"too many redirects\"", "            redirect_location = response.get_redirect_location()", "            status = response.status", "    ", "        else:", "            # Incrementing because of a server error like a 500 in", "            # status_forcelist and a the given method is in the whitelist", "            cause = ResponseError.GENERIC_ERROR", "            if response and response.status:", "                if status_count is not None:", "                    status_count -= 1", "                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)", "                status = response.status", "    ", "        history = self.history + (", "            RequestHistory(method, url, error, status, redirect_location),", "        )", "    ", "        new_retry = self.new(", "            total=total,", "            connect=connect,", "            read=read,", "            redirect=redirect,", "            status=status_count,", "            history=history,", "        )", "    ", "        if new_retry.is_exhausted():", ">           raise MaxRetryError(_pool, url, error or ResponseError(cause))", "E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=4723): Max retries exceeded with url: /wd/hub/session (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001E1C784DDF0>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002'))"], "reprfuncargs": {"args": [["self", "Retry(total=0, connect=None, read=None, redirect=None, status=None)"], ["method", "'POST'"], ["url", "'/wd/hub/session'"], ["response", "None"], ["error", "NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001E1C784DDF0>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002')"], ["_pool", "<urllib3.connectionpool.HTTPConnectionPool object at 0x000001E1C784D8B0>"], ["_stacktrace", "<traceback object at 0x000001E1C79C0AC0>"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\util\\retry.py", "lineno": 436, "message": "MaxRetryError"}, "style": "long"}}], "extraline": null, "style": "long"}, "sections": [], "chain": [[{"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    def _new_conn(self):", "        \"\"\" Establish a socket connection and set nodelay settings on it.", "    ", "        :return: New socket connection.", "        \"\"\"", "        extra_kw = {}", "        if self.source_address:", "            extra_kw[\"source_address\"] = self.source_address", "    ", "        if self.socket_options:", "            extra_kw[\"socket_options\"] = self.socket_options", "    ", "        try:", ">           conn = connection.create_connection(", "                (self._dns_host, self.port), self.timeout, **extra_kw", "            )"], "reprfuncargs": {"args": [["self", "<urllib3.connection.HTTPConnection object at 0x000001E1C784DDF0>"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connection.py", "lineno": 156, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    def create_connection(", "        address,", "        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,", "        source_address=None,", "        socket_options=None,", "    ):", "        \"\"\"Connect to *address* and return the socket object.", "    ", "        Convenience function.  Connect to *address* (a 2-tuple ``(host,", "        port)``) and return the socket object.  Passing the optional", "        *timeout* parameter will set the timeout on the socket instance", "        before attempting to connect.  If no *timeout* is supplied, the", "        global default timeout setting returned by :func:`getdefaulttimeout`", "        is used.  If *source_address* is set it must be a tuple of (host, port)", "        for the socket to bind as a source address before making the connection.", "        An host of '' or port 0 tells the OS to use the default.", "        \"\"\"", "    ", "        host, port = address", "        if host.startswith(\"[\"):", "            host = host.strip(\"[]\")", "        err = None", "    ", "        # Using the value from allowed_gai_family() in the context of getaddrinfo lets", "        # us select whether to work with IPv4 DNS records, IPv6 records, or both.", "        # The original create_connection function always returns all records.", "        family = allowed_gai_family()", "    ", "        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):", "            af, socktype, proto, canonname, sa = res", "            sock = None", "            try:", "                sock = socket.socket(af, socktype, proto)", "    ", "                # If provided, set socket level options before connecting.", "                _set_socket_options(sock, socket_options)", "    ", "                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:", "                    sock.settimeout(timeout)", "                if source_address:", "                    sock.bind(source_address)", "                sock.connect(sa)", "                return sock", "    ", "            except socket.error as e:", "                err = e", "                if sock is not None:", "                    sock.close()", "                    sock = None", "    ", "        if err is not None:", ">           raise err"], "reprfuncargs": {"args": [["address", "('127.0.0.1', 4723)"], ["timeout", "<object object at 0x000001E1C577A580>"], ["source_address", "None"], ["socket_options", "[(6, 1, 1)]"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\util\\connection.py", "lineno": 84, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    def create_connection(", "        address,", "        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,", "        source_address=None,", "        socket_options=None,", "    ):", "        \"\"\"Connect to *address* and return the socket object.", "    ", "        Convenience function.  Connect to *address* (a 2-tuple ``(host,", "        port)``) and return the socket object.  Passing the optional", "        *timeout* parameter will set the timeout on the socket instance", "        before attempting to connect.  If no *timeout* is supplied, the", "        global default timeout setting returned by :func:`getdefaulttimeout`", "        is used.  If *source_address* is set it must be a tuple of (host, port)", "        for the socket to bind as a source address before making the connection.", "        An host of '' or port 0 tells the OS to use the default.", "        \"\"\"", "    ", "        host, port = address", "        if host.startswith(\"[\"):", "            host = host.strip(\"[]\")", "        err = None", "    ", "        # Using the value from allowed_gai_family() in the context of getaddrinfo lets", "        # us select whether to work with IPv4 DNS records, IPv6 records, or both.", "        # The original create_connection function always returns all records.", "        family = allowed_gai_family()", "    ", "        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):", "            af, socktype, proto, canonname, sa = res", "            sock = None", "            try:", "                sock = socket.socket(af, socktype, proto)", "    ", "                # If provided, set socket level options before connecting.", "                _set_socket_options(sock, socket_options)", "    ", "                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:", "                    sock.settimeout(timeout)", "                if source_address:", "                    sock.bind(source_address)", ">               sock.connect(sa)", "E               ConnectionRefusedError: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002"], "reprfuncargs": {"args": [["address", "('127.0.0.1', 4723)"], ["timeout", "<object object at 0x000001E1C577A580>"], ["source_address", "None"], ["socket_options", "[(6, 1, 1)]"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\util\\connection.py", "lineno": 74, "message": "ConnectionRefusedError"}, "style": "long"}}], "extraline": null, "style": "long"}, {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\util\\connection.py", "lineno": 74, "message": "ConnectionRefusedError: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002"}, "During handling of the above exception, another exception occurred:"], [{"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    def urlopen(", "        self,", "        method,", "        url,", "        body=None,", "        headers=None,", "        retries=None,", "        redirect=True,", "        assert_same_host=True,", "        timeout=_Default,", "        pool_timeout=None,", "        release_conn=None,", "        chunked=False,", "        body_pos=None,", "        **response_kw", "    ):", "        \"\"\"", "        Get a connection from the pool and perform an HTTP request. This is the", "        lowest level call for making a request, so you'll need to specify all", "        the raw details.", "    ", "        .. note::", "    ", "           More commonly, it's appropriate to use a convenience method provided", "           by :class:`.RequestMethods`, such as :meth:`request`.", "    ", "        .. note::", "    ", "           `release_conn` will only behave as expected if", "           `preload_content=False` because we want to make", "           `preload_content=False` the default behaviour someday soon without", "           breaking backwards compatibility.", "    ", "        :param method:", "            HTTP request method (such as GET, POST, PUT, etc.)", "    ", "        :param body:", "            Data to send in the request body (useful for creating", "            POST requests, see HTTPConnectionPool.post_url for", "            more convenience).", "    ", "        :param headers:", "            Dictionary of custom headers to send, such as User-Agent,", "            If-None-Match, etc. If None, pool headers are used. If provided,", "            these headers completely replace any pool-specific headers.", "    ", "        :param retries:", "            Configure the number of retries to allow before raising a", "            :class:`~urllib3.exceptions.MaxRetryError` exception.", "    ", "            Pass ``None`` to retry until you receive a response. Pass a", "            :class:`~urllib3.util.retry.Retry` object for fine-grained control", "            over different types of retries.", "            Pass an integer number to retry connection errors that many times,", "            but no other types of errors. Pass zero to never retry.", "    ", "            If ``False``, then retries are disabled and any exception is raised", "            immediately. Also, instead of raising a MaxRetryError on redirects,", "            the redirect response will be returned.", "    ", "        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.", "    ", "        :param redirect:", "            If True, automatically handle redirects (status codes 301, 302,", "            303, 307, 308). Each redirect counts as a retry. Disabling retries", "            will disable redirect, too.", "    ", "        :param assert_same_host:", "            If ``True``, will make sure that the host of the pool requests is", "            consistent else will raise HostChangedError. When False, you can", "            use the pool on an HTTP proxy and request foreign hosts.", "    ", "        :param timeout:", "            If specified, overrides the default timeout for this one", "            request. It may be a float (in seconds) or an instance of", "            :class:`urllib3.util.Timeout`.", "    ", "        :param pool_timeout:", "            If set and the pool is set to block=True, then this method will", "            block for ``pool_timeout`` seconds and raise EmptyPoolError if no", "            connection is available within the time period.", "    ", "        :param release_conn:", "            If False, then the urlopen call will not release the connection", "            back into the pool once a response is received (but will release if", "            you read the entire contents of the response such as when", "            `preload_content=True`). This is useful if you're not preloading", "            the response's content immediately. You will need to call", "            ``r.release_conn()`` on the response ``r`` to return the connection", "            back into the pool. If None, it takes the value of", "            ``response_kw.get('preload_content', True)``.", "    ", "        :param chunked:", "            If True, urllib3 will send the body using chunked transfer", "            encoding. Otherwise, urllib3 will send the body using the standard", "            content-length form. Defaults to False.", "    ", "        :param int body_pos:", "            Position to seek to in file-like body in the event of a retry or", "            redirect. Typically this won't need to be set because urllib3 will", "            auto-populate the value when needed.", "    ", "        :param \\\\**response_kw:", "            Additional parameters are passed to", "            :meth:`urllib3.response.HTTPResponse.from_httplib`", "        \"\"\"", "        if headers is None:", "            headers = self.headers", "    ", "        if not isinstance(retries, Retry):", "            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)", "    ", "        if release_conn is None:", "            release_conn = response_kw.get(\"preload_content\", True)", "    ", "        # Check host", "        if assert_same_host and not self.is_same_host(url):", "            raise HostChangedError(self, url, retries)", "    ", "        # Ensure that the URL we're connecting to is properly encoded", "        if url.startswith(\"/\"):", "            url = six.ensure_str(_encode_target(url))", "        else:", "            url = six.ensure_str(parse_url(url).url)", "    ", "        conn = None", "    ", "        # Track whether `conn` needs to be released before", "        # returning/raising/recursing. Update this variable if necessary, and", "        # leave `release_conn` constant throughout the function. That way, if", "        # the function recurses, the original value of `release_conn` will be", "        # passed down into the recursive call, and its value will be respected.", "        #", "        # See issue #651 [1] for details.", "        #", "        # [1] <https://github.com/urllib3/urllib3/issues/651>", "        release_this_conn = release_conn", "    ", "        # Merge the proxy headers. Only do this in HTTP. We have to copy the", "        # headers dict so we can safely change it without those changes being", "        # reflected in anyone else's copy.", "        if self.scheme == \"http\":", "            headers = headers.copy()", "            headers.update(self.proxy_headers)", "    ", "        # Must keep the exception bound to a separate variable or else Python 3", "        # complains about UnboundLocalError.", "        err = None", "    ", "        # Keep track of whether we cleanly exited the except block. This", "        # ensures we do proper cleanup in finally.", "        clean_exit = False", "    ", "        # Rewind body position, if needed. Record current position", "        # for future rewinds in the event of a redirect/retry.", "        body_pos = set_file_position(body, body_pos)", "    ", "        try:", "            # Request a connection from the queue.", "            timeout_obj = self._get_timeout(timeout)", "            conn = self._get_conn(timeout=pool_timeout)", "    ", "            conn.timeout = timeout_obj.connect_timeout", "    ", "            is_new_proxy_conn = self.proxy is not None and not getattr(", "                conn, \"sock\", None", "            )", "            if is_new_proxy_conn:", "                self._prepare_proxy(conn)", "    ", "            # Make the request on the httplib connection object.", ">           httplib_response = self._make_request(", "                conn,", "                method,", "                url,", "                timeout=timeout_obj,", "                body=body,", "                headers=headers,", "                chunked=chunked,", "            )"], "reprfuncargs": {"args": [["self", "<urllib3.connectionpool.HTTPConnectionPool object at 0x000001E1C784D8B0>"], ["method", "'POST'"], ["url", "'/wd/hub/session'"], ["body", "'{\"capabilities\": {\"firstMatch\": [{\"platformName\": \"Android\", \"appium:platformVersion\": 9.0, \"appium:deviceName\": \"And...noReset\": false, \"appPackage\": \"com.xxzb.fenwoo\", \"appActivity\": \"com.xxzb.fenwoo.activity.addition.WelcomeActivity\"}}'"], ["headers", "{'Accept': 'application/json', 'Connection': 'keep-alive', 'Content-Type': 'application/json;charset=UTF-8', 'User-Agent': 'appium/python 0.50 (selenium/3.141.0 (python windows))'}"], ["retries", "Retry(total=0, connect=None, read=None, redirect=None, status=None)"], ["redirect", "False"], ["assert_same_host", "False"], ["timeout", "<object object at 0x000001E1C69881B0>"], ["pool_timeout", "None"], ["release_conn", "True"], ["chunked", "False"], ["body_pos", "None"], ["response_kw", "{'request_url': 'http://127.0.0.1:4723/wd/hub/session'}"], ["conn", "None"], ["release_this_conn", "True"], ["err", "None"], ["clean_exit", "False"], ["timeout_obj", "<urllib3.util.timeout.Timeout object at 0x000001E1C784DCD0>"], ["is_new_proxy_conn", "False"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connectionpool.py", "lineno": 665, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    def _make_request(", "        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw", "    ):", "        \"\"\"", "        Perform a request on a given urllib connection object taken from our", "        pool.", "    ", "        :param conn:", "            a connection from one of our connection pools", "    ", "        :param timeout:", "            Socket timeout in seconds for the request. This can be a", "            float or integer, which will set the same timeout value for", "            the socket connect and the socket read, or an instance of", "            :class:`urllib3.util.Timeout`, which gives you more fine-grained", "            control over your timeouts.", "        \"\"\"", "        self.num_requests += 1", "    ", "        timeout_obj = self._get_timeout(timeout)", "        timeout_obj.start_connect()", "        conn.timeout = timeout_obj.connect_timeout", "    ", "        # Trigger any extra validation we need to do.", "        try:", "            self._validate_conn(conn)", "        except (SocketTimeout, BaseSSLError) as e:", "            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.", "            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)", "            raise", "    ", "        # conn.request() calls httplib.*.request, not the method in", "        # urllib3.request. It also calls makefile (recv) on the socket.", "        if chunked:", "            conn.request_chunked(method, url, **httplib_request_kw)", "        else:", ">           conn.request(method, url, **httplib_request_kw)"], "reprfuncargs": {"args": [["self", "<urllib3.connectionpool.HTTPConnectionPool object at 0x000001E1C784D8B0>"], ["conn", "<urllib3.connection.HTTPConnection object at 0x000001E1C784DDF0>"], ["method", "'POST'"], ["url", "'/wd/hub/session'"], ["timeout", "<urllib3.util.timeout.Timeout object at 0x000001E1C784DCD0>"], ["chunked", "False"], ["httplib_request_kw", "{'body': '{\"capabilities\": {\"firstMatch\": [{\"platformName\": \"Android\", \"appium:platformVersion\": 9.0, \"appium:deviceNa...ntent-Type': 'application/json;charset=UTF-8', 'User-Agent': 'appium/python 0.50 (selenium/3.141.0 (python windows))'}}"], ["timeout_obj", "<urllib3.util.timeout.Timeout object at 0x000001E1C784DB80>"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connectionpool.py", "lineno": 387, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    def request(self, method, url, body=None, headers={}, *,", "                encode_chunked=False):", "        \"\"\"Send a complete request to the server.\"\"\"", ">       self._send_request(method, url, body, headers, encode_chunked)"], "reprfuncargs": {"args": [["self", "<urllib3.connection.HTTPConnection object at 0x000001E1C784DDF0>"], ["method", "'POST'"], ["url", "'/wd/hub/session'"], ["body", "'{\"capabilities\": {\"firstMatch\": [{\"platformName\": \"Android\", \"appium:platformVersion\": 9.0, \"appium:deviceName\": \"And...noReset\": false, \"appPackage\": \"com.xxzb.fenwoo\", \"appActivity\": \"com.xxzb.fenwoo.activity.addition.WelcomeActivity\"}}'"], ["headers", "{'Accept': 'application/json', 'Connection': 'keep-alive', 'Content-Type': 'application/json;charset=UTF-8', 'User-Agent': 'appium/python 0.50 (selenium/3.141.0 (python windows))'}"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\http\\client.py", "lineno": 1230, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    def _send_request(self, method, url, body, headers, encode_chunked):", "        # Honor explicitly requested Host: and Accept-Encoding: headers.", "        header_names = frozenset(k.lower() for k in headers)", "        skips = {}", "        if 'host' in header_names:", "            skips['skip_host'] = 1", "        if 'accept-encoding' in header_names:", "            skips['skip_accept_encoding'] = 1", "    ", "        self.putrequest(method, url, **skips)", "    ", "        # chunked encoding will happen if HTTP/1.1 is used and either", "        # the caller passes encode_chunked=True or the following", "        # conditions hold:", "        # 1. content-length has not been explicitly set", "        # 2. the body is a file or iterable, but not a str or bytes-like", "        # 3. Transfer-Encoding has NOT been explicitly set by the caller", "    ", "        if 'content-length' not in header_names:", "            # only chunk body if not explicitly set for backwards", "            # compatibility, assuming the client code is already handling the", "            # chunking", "            if 'transfer-encoding' not in header_names:", "                # if content-length cannot be automatically determined, fall", "                # back to chunked encoding", "                encode_chunked = False", "                content_length = self._get_content_length(body, method)", "                if content_length is None:", "                    if body is not None:", "                        if self.debuglevel > 0:", "                            print('Unable to determine size of %r' % body)", "                        encode_chunked = True", "                        self.putheader('Transfer-Encoding', 'chunked')", "                else:", "                    self.putheader('Content-Length', str(content_length))", "        else:", "            encode_chunked = False", "    ", "        for hdr, value in headers.items():", "            self.putheader(hdr, value)", "        if isinstance(body, str):", "            # RFC 2616 Section 3.7.1 says that text default has a", "            # default charset of iso-8859-1.", "            body = _encode(body, 'body')", ">       self.endheaders(body, encode_chunked=encode_chunked)"], "reprfuncargs": {"args": [["self", "<urllib3.connection.HTTPConnection object at 0x000001E1C784DDF0>"], ["method", "'POST'"], ["url", "'/wd/hub/session'"], ["body", "b'{\"capabilities\": {\"firstMatch\": [{\"platformName\": \"Android\", \"appium:platformVersion\": 9.0, \"appium:deviceName\": \"An...noReset\": false, \"appPackage\": \"com.xxzb.fenwoo\", \"appActivity\": \"com.xxzb.fenwoo.activity.addition.WelcomeActivity\"}}'"], ["headers", "{'Accept': 'application/json', 'Connection': 'keep-alive', 'Content-Type': 'application/json;charset=UTF-8', 'User-Agent': 'appium/python 0.50 (selenium/3.141.0 (python windows))'}"], ["encode_chunked", "False"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\http\\client.py", "lineno": 1276, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    def endheaders(self, message_body=None, *, encode_chunked=False):", "        \"\"\"Indicate that the last header line has been sent to the server.", "    ", "        This method sends the request to the server.  The optional message_body", "        argument can be used to pass a message body associated with the", "        request.", "        \"\"\"", "        if self.__state == _CS_REQ_STARTED:", "            self.__state = _CS_REQ_SENT", "        else:", "            raise CannotSendHeader()", ">       self._send_output(message_body, encode_chunked=encode_chunked)"], "reprfuncargs": {"args": [["self", "<urllib3.connection.HTTPConnection object at 0x000001E1C784DDF0>"], ["message_body", "b'{\"capabilities\": {\"firstMatch\": [{\"platformName\": \"Android\", \"appium:platformVersion\": 9.0, \"appium:deviceName\": \"An...noReset\": false, \"appPackage\": \"com.xxzb.fenwoo\", \"appActivity\": \"com.xxzb.fenwoo.activity.addition.WelcomeActivity\"}}'"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\http\\client.py", "lineno": 1225, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    def _send_output(self, message_body=None, encode_chunked=False):", "        \"\"\"Send the currently buffered request and clear the buffer.", "    ", "        Appends an extra \\\\r\\\\n to the buffer.", "        A message_body may be specified, to be appended to the request.", "        \"\"\"", "        self._buffer.extend((b\"\", b\"\"))", "        msg = b\"\\r\\n\".join(self._buffer)", "        del self._buffer[:]", ">       self.send(msg)"], "reprfuncargs": {"args": [["self", "<urllib3.connection.HTTPConnection object at 0x000001E1C784DDF0>"], ["message_body", "b'{\"capabilities\": {\"firstMatch\": [{\"platformName\": \"Android\", \"appium:platformVersion\": 9.0, \"appium:deviceName\": \"An...noReset\": false, \"appPackage\": \"com.xxzb.fenwoo\", \"appActivity\": \"com.xxzb.fenwoo.activity.addition.WelcomeActivity\"}}'"], ["encode_chunked", "False"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\http\\client.py", "lineno": 1004, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    def send(self, data):", "        \"\"\"Send `data' to the server.", "        ``data`` can be a string object, a bytes object, an array object, a", "        file-like object that supports a .read() method, or an iterable object.", "        \"\"\"", "    ", "        if self.sock is None:", "            if self.auto_open:", ">               self.connect()"], "reprfuncargs": {"args": [["self", "<urllib3.connection.HTTPConnection object at 0x000001E1C784DDF0>"], ["data", "b'POST /wd/hub/session HTTP/1.1\\r\\nHost: 127.0.0.1:4723\\r\\nAccept-Encoding: identity\\r\\nContent-Length: 567\\r\\nAccept:...;charset=UTF-8\\r\\nUser-Agent: appium/python 0.50 (selenium/3.141.0 (python windows))\\r\\nConnection: keep-alive\\r\\n\\r\\n'"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\http\\client.py", "lineno": 944, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    def connect(self):", ">       conn = self._new_conn()"], "reprfuncargs": {"args": [["self", "<urllib3.connection.HTTPConnection object at 0x000001E1C784DDF0>"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connection.py", "lineno": 184, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    def _new_conn(self):", "        \"\"\" Establish a socket connection and set nodelay settings on it.", "    ", "        :return: New socket connection.", "        \"\"\"", "        extra_kw = {}", "        if self.source_address:", "            extra_kw[\"source_address\"] = self.source_address", "    ", "        if self.socket_options:", "            extra_kw[\"socket_options\"] = self.socket_options", "    ", "        try:", "            conn = connection.create_connection(", "                (self._dns_host, self.port), self.timeout, **extra_kw", "            )", "    ", "        except SocketTimeout:", "            raise ConnectTimeoutError(", "                self,", "                \"Connection to %s timed out. (connect timeout=%s)\"", "                % (self.host, self.timeout),", "            )", "    ", "        except SocketError as e:", ">           raise NewConnectionError(", "                self, \"Failed to establish a new connection: %s\" % e", "            )", "E           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x000001E1C784DDF0>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002"], "reprfuncargs": {"args": [["self", "<urllib3.connection.HTTPConnection object at 0x000001E1C784DDF0>"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connection.py", "lineno": 168, "message": "NewConnectionError"}, "style": "long"}}], "extraline": null, "style": "long"}, {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connection.py", "lineno": 168, "message": "urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x000001E1C784DDF0>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002"}, "During handling of the above exception, another exception occurred:"], [{"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    @pytest.fixture()", "    def init_keep():", ">       driver = base_driver(automationName=None,noReset=False)"], "reprfuncargs": {"args": []}, "reprlocals": null, "reprfileloc": {"path": "TestCases\\conftest.py", "lineno": 75, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    driver = webdriver.Remote(\"http://127.0.0.1:{}/wd/hub\".format(server_port),descired_caps)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "TestCases\\conftest.py", "lineno": 33, "message": "in base_driver"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    super(WebDriver, self).__init__("], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\appium\\webdriver\\webdriver.py", "lineno": 147, "message": "in __init__"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    self.start_session(capabilities, browser_profile)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\selenium\\webdriver\\remote\\webdriver.py", "lineno": 157, "message": "in __init__"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    response = self.execute(RemoteCommand.NEW_SESSION, parameters)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\appium\\webdriver\\webdriver.py", "lineno": 227, "message": "in start_session"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    response = self.command_executor.execute(driver_command, params)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\selenium\\webdriver\\remote\\webdriver.py", "lineno": 319, "message": "in execute"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return self._request(command_info[0], url, body=data)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\selenium\\webdriver\\remote\\remote_connection.py", "lineno": 374, "message": "in execute"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    resp = self._conn.request(method, url, body=body, headers=headers)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\selenium\\webdriver\\remote\\remote_connection.py", "lineno": 397, "message": "in _request"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return self.request_encode_body("], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\request.py", "lineno": 79, "message": "in request"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return self.urlopen(method, url, **extra_kw)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\request.py", "lineno": 171, "message": "in request_encode_body"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    response = conn.urlopen(method, u.request_uri, **kw)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\poolmanager.py", "lineno": 330, "message": "in urlopen"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return self.urlopen("], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connectionpool.py", "lineno": 747, "message": "in urlopen"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return self.urlopen("], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connectionpool.py", "lineno": 747, "message": "in urlopen"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return self.urlopen("], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connectionpool.py", "lineno": 747, "message": "in urlopen"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    retries = retries.increment("], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\connectionpool.py", "lineno": 719, "message": "in urlopen"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    def increment(", "        self,", "        method=None,", "        url=None,", "        response=None,", "        error=None,", "        _pool=None,", "        _stacktrace=None,", "    ):", "        \"\"\" Return a new Retry object with incremented retry counters.", "    ", "        :param response: A response object, or None, if the server did not", "            return a response.", "        :type response: :class:`~urllib3.response.HTTPResponse`", "        :param Exception error: An error encountered during the request, or", "            None if the response was received successfully.", "    ", "        :return: A new ``Retry`` object.", "        \"\"\"", "        if self.total is False and error:", "            # Disabled, indicate to re-raise the error.", "            raise six.reraise(type(error), error, _stacktrace)", "    ", "        total = self.total", "        if total is not None:", "            total -= 1", "    ", "        connect = self.connect", "        read = self.read", "        redirect = self.redirect", "        status_count = self.status", "        cause = \"unknown\"", "        status = None", "        redirect_location = None", "    ", "        if error and self._is_connection_error(error):", "            # Connect retry?", "            if connect is False:", "                raise six.reraise(type(error), error, _stacktrace)", "            elif connect is not None:", "                connect -= 1", "    ", "        elif error and self._is_read_error(error):", "            # Read retry?", "            if read is False or not self._is_method_retryable(method):", "                raise six.reraise(type(error), error, _stacktrace)", "            elif read is not None:", "                read -= 1", "    ", "        elif response and response.get_redirect_location():", "            # Redirect retry?", "            if redirect is not None:", "                redirect -= 1", "            cause = \"too many redirects\"", "            redirect_location = response.get_redirect_location()", "            status = response.status", "    ", "        else:", "            # Incrementing because of a server error like a 500 in", "            # status_forcelist and a the given method is in the whitelist", "            cause = ResponseError.GENERIC_ERROR", "            if response and response.status:", "                if status_count is not None:", "                    status_count -= 1", "                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)", "                status = response.status", "    ", "        history = self.history + (", "            RequestHistory(method, url, error, status, redirect_location),", "        )", "    ", "        new_retry = self.new(", "            total=total,", "            connect=connect,", "            read=read,", "            redirect=redirect,", "            status=status_count,", "            history=history,", "        )", "    ", "        if new_retry.is_exhausted():", ">           raise MaxRetryError(_pool, url, error or ResponseError(cause))", "E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=4723): Max retries exceeded with url: /wd/hub/session (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001E1C784DDF0>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002'))"], "reprfuncargs": {"args": [["self", "Retry(total=0, connect=None, read=None, redirect=None, status=None)"], ["method", "'POST'"], ["url", "'/wd/hub/session'"], ["response", "None"], ["error", "NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001E1C784DDF0>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002')"], ["_pool", "<urllib3.connectionpool.HTTPConnectionPool object at 0x000001E1C784D8B0>"], ["_stacktrace", "<traceback object at 0x000001E1C79C0AC0>"]]}, "reprlocals": null, "reprfileloc": {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\util\\retry.py", "lineno": 436, "message": "MaxRetryError"}, "style": "long"}}], "extraline": null, "style": "long"}, {"path": "D:\\Program Files (x86)\\python\\lib\\site-packages\\urllib3\\util\\retry.py", "lineno": 436, "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=4723): Max retries exceeded with url: /wd/hub/session (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001E1C784DDF0>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002'))"}, null]]}, "when": "setup", "user_properties": [], "sections": [["Captured log setup", "\u001b[32mINFO    \u001b[0m selenium.webdriver.remote.remote_connection:remote_connection.py:116 Could not connect to port 4723 on host 127.0.0.1\n\u001b[32mINFO    \u001b[0m selenium.webdriver.remote.remote_connection:remote_connection.py:135 Could not get IP address for host: 127.0.0.1\n\u001b[33mWARNING \u001b[0m urllib3.connectionpool:connectionpool.py:744 Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001E1C784D7C0>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002')': /wd/hub/session\n\u001b[33mWARNING \u001b[0m urllib3.connectionpool:connectionpool.py:744 Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001E1C784DA30>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002')': /wd/hub/session\n\u001b[33mWARNING \u001b[0m urllib3.connectionpool:connectionpool.py:744 Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001E1C784D9D0>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002')': /wd/hub/session"]], "duration": 5.028178930282593, "_report_type": "TestReport"}
{"nodeid": "TestCases/test_0_login.py::TestLogin::test_login_success", "location": ["TestCases\\test_0_login.py", 23, "TestLogin.test_login_success"], "keywords": {"test_0_login.py": 1, "test_login_success": 1, "TestLogin": 1, "usefixtures": 1, "test": 1, "TestCases/__init__.py": 1, "()": 1, "AppFramework": 1, "pytestmark": 1}, "outcome": "passed", "longrepr": null, "when": "teardown", "user_properties": [], "sections": [["Captured log setup", "\u001b[32mINFO    \u001b[0m selenium.webdriver.remote.remote_connection:remote_connection.py:116 Could not connect to port 4723 on host 127.0.0.1\n\u001b[32mINFO    \u001b[0m selenium.webdriver.remote.remote_connection:remote_connection.py:135 Could not get IP address for host: 127.0.0.1\n\u001b[33mWARNING \u001b[0m urllib3.connectionpool:connectionpool.py:744 Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001E1C784D7C0>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002')': /wd/hub/session\n\u001b[33mWARNING \u001b[0m urllib3.connectionpool:connectionpool.py:744 Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001E1C784DA30>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002')': /wd/hub/session\n\u001b[33mWARNING \u001b[0m urllib3.connectionpool:connectionpool.py:744 Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001E1C784D9D0>: Failed to establish a new connection: [WinError 10061] \u7531\u4e8e\u76ee\u6807\u8ba1\u7b97\u673a\u79ef\u6781\u62d2\u7edd\uff0c\u65e0\u6cd5\u8fde\u63a5\u3002')': /wd/hub/session"]], "duration": 0.0009763240814208984, "_report_type": "TestReport"}
{"exitstatus": 1, "$report_type": "SessionFinish"}
